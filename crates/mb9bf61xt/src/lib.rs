#![doc = "Peripheral access API for MB9BF61XT microcontrollers (generated using svd2rust v0.31.5 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.31.5/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn CSV();
    fn SWDT();
    fn LVD();
    fn WFG();
    fn EXTINT0_7();
    fn EXTINT8_31();
    fn DTIM_QDU();
    fn MFS0RX();
    fn MFS0TX();
    fn MFS1RX();
    fn MFS1TX();
    fn MFS2RX();
    fn MFS2TX();
    fn MFS3RX();
    fn MFS3TX();
    fn MFS4RX();
    fn MFS4TX();
    fn MFS5RX();
    fn MFS5TX();
    fn MFS6RX();
    fn MFS6TX();
    fn MFS7RX();
    fn MFS7TX();
    fn PPG();
    fn OSC_PLL_WC();
    fn ADC0();
    fn ADC1();
    fn ADC2();
    fn FRTIM();
    fn INCAP();
    fn OUTCOMP();
    fn BTIM0_7();
    fn ETHER_MAC0();
    fn ETHER_MAC1();
    fn USB0F();
    fn USB0F_USB0H();
    fn USB1F();
    fn USB1F_USB1H();
    fn DMAC0();
    fn DMAC1();
    fn DMAC2();
    fn DMAC3();
    fn DMAC4();
    fn DMAC5();
    fn DMAC6();
    fn DMAC7();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 46] = [
    Vector { _handler: CSV },
    Vector { _handler: SWDT },
    Vector { _handler: LVD },
    Vector { _handler: WFG },
    Vector {
        _handler: EXTINT0_7,
    },
    Vector {
        _handler: EXTINT8_31,
    },
    Vector { _handler: DTIM_QDU },
    Vector { _handler: MFS0RX },
    Vector { _handler: MFS0TX },
    Vector { _handler: MFS1RX },
    Vector { _handler: MFS1TX },
    Vector { _handler: MFS2RX },
    Vector { _handler: MFS2TX },
    Vector { _handler: MFS3RX },
    Vector { _handler: MFS3TX },
    Vector { _handler: MFS4RX },
    Vector { _handler: MFS4TX },
    Vector { _handler: MFS5RX },
    Vector { _handler: MFS5TX },
    Vector { _handler: MFS6RX },
    Vector { _handler: MFS6TX },
    Vector { _handler: MFS7RX },
    Vector { _handler: MFS7TX },
    Vector { _handler: PPG },
    Vector {
        _handler: OSC_PLL_WC,
    },
    Vector { _handler: ADC0 },
    Vector { _handler: ADC1 },
    Vector { _handler: ADC2 },
    Vector { _handler: FRTIM },
    Vector { _handler: INCAP },
    Vector { _handler: OUTCOMP },
    Vector { _handler: BTIM0_7 },
    Vector {
        _handler: ETHER_MAC0,
    },
    Vector {
        _handler: ETHER_MAC1,
    },
    Vector { _handler: USB0F },
    Vector {
        _handler: USB0F_USB0H,
    },
    Vector { _handler: USB1F },
    Vector {
        _handler: USB1F_USB1H,
    },
    Vector { _handler: DMAC0 },
    Vector { _handler: DMAC1 },
    Vector { _handler: DMAC2 },
    Vector { _handler: DMAC3 },
    Vector { _handler: DMAC4 },
    Vector { _handler: DMAC5 },
    Vector { _handler: DMAC6 },
    Vector { _handler: DMAC7 },
];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "0 - CSV"]
    CSV = 0,
    #[doc = "1 - SWDT"]
    SWDT = 1,
    #[doc = "2 - LVD"]
    LVD = 2,
    #[doc = "3 - WFG"]
    WFG = 3,
    #[doc = "4 - EXTINT0_7"]
    EXTINT0_7 = 4,
    #[doc = "5 - EXTINT8_31"]
    EXTINT8_31 = 5,
    #[doc = "6 - DTIM_QDU"]
    DTIM_QDU = 6,
    #[doc = "7 - MFS0RX"]
    MFS0RX = 7,
    #[doc = "8 - MFS0TX"]
    MFS0TX = 8,
    #[doc = "9 - MFS1RX"]
    MFS1RX = 9,
    #[doc = "10 - MFS1TX"]
    MFS1TX = 10,
    #[doc = "11 - MFS2RX"]
    MFS2RX = 11,
    #[doc = "12 - MFS2TX"]
    MFS2TX = 12,
    #[doc = "13 - MFS3RX"]
    MFS3RX = 13,
    #[doc = "14 - MFS3TX"]
    MFS3TX = 14,
    #[doc = "15 - MFS4RX"]
    MFS4RX = 15,
    #[doc = "16 - MFS4TX"]
    MFS4TX = 16,
    #[doc = "17 - MFS5RX"]
    MFS5RX = 17,
    #[doc = "18 - MFS5TX"]
    MFS5TX = 18,
    #[doc = "19 - MFS6RX"]
    MFS6RX = 19,
    #[doc = "20 - MFS6TX"]
    MFS6TX = 20,
    #[doc = "21 - MFS7RX"]
    MFS7RX = 21,
    #[doc = "22 - MFS7TX"]
    MFS7TX = 22,
    #[doc = "23 - PPG"]
    PPG = 23,
    #[doc = "24 - OSC_PLL_WC"]
    OSC_PLL_WC = 24,
    #[doc = "25 - ADC0"]
    ADC0 = 25,
    #[doc = "26 - ADC1"]
    ADC1 = 26,
    #[doc = "27 - ADC2"]
    ADC2 = 27,
    #[doc = "28 - FRTIM"]
    FRTIM = 28,
    #[doc = "29 - INCAP"]
    INCAP = 29,
    #[doc = "30 - OUTCOMP"]
    OUTCOMP = 30,
    #[doc = "31 - BTIM0_7"]
    BTIM0_7 = 31,
    #[doc = "32 - ETHER_MAC0"]
    ETHER_MAC0 = 32,
    #[doc = "33 - ETHER_MAC1"]
    ETHER_MAC1 = 33,
    #[doc = "34 - USB0F"]
    USB0F = 34,
    #[doc = "35 - USB0F_USB0H"]
    USB0F_USB0H = 35,
    #[doc = "36 - USB1F"]
    USB1F = 36,
    #[doc = "37 - USB1F_USB1H"]
    USB1F_USB1H = 37,
    #[doc = "38 - DMAC0"]
    DMAC0 = 38,
    #[doc = "39 - DMAC1"]
    DMAC1 = 39,
    #[doc = "40 - DMAC2"]
    DMAC2 = 40,
    #[doc = "41 - DMAC3"]
    DMAC3 = 41,
    #[doc = "42 - DMAC4"]
    DMAC4 = 42,
    #[doc = "43 - DMAC5"]
    DMAC5 = 43,
    #[doc = "44 - DMAC6"]
    DMAC6 = 44,
    #[doc = "45 - DMAC7"]
    DMAC7 = 45,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "Flash Memory"]
pub struct FLASH_IF {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FLASH_IF {}
impl FLASH_IF {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const flash_if::RegisterBlock = 0x4000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const flash_if::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for FLASH_IF {
    type Target = flash_if::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FLASH_IF {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FLASH_IF").finish()
    }
}
#[doc = "Flash Memory"]
pub mod flash_if;
#[doc = "Clock Unit Registers"]
pub struct CRG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CRG {}
impl CRG {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const crg::RegisterBlock = 0x4001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const crg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CRG {
    type Target = crg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CRG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CRG").finish()
    }
}
#[doc = "Clock Unit Registers"]
pub mod crg;
#[doc = "CR Trimming Registers"]
pub struct CRTRIM {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CRTRIM {}
impl CRTRIM {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const crtrim::RegisterBlock = 0x4002_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const crtrim::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CRTRIM {
    type Target = crtrim::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CRTRIM {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CRTRIM").finish()
    }
}
#[doc = "CR Trimming Registers"]
pub mod crtrim;
#[doc = "Software Watchdog Timer"]
pub struct SWWDT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SWWDT {}
impl SWWDT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const swwdt::RegisterBlock = 0x4001_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const swwdt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SWWDT {
    type Target = swwdt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SWWDT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SWWDT").finish()
    }
}
#[doc = "Software Watchdog Timer"]
pub mod swwdt;
#[doc = "Hardware Watchdog Timer"]
pub struct HWWDT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for HWWDT {}
impl HWWDT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const hwwdt::RegisterBlock = 0x4001_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const hwwdt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for HWWDT {
    type Target = hwwdt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for HWWDT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("HWWDT").finish()
    }
}
#[doc = "Hardware Watchdog Timer"]
pub mod hwwdt;
#[doc = "Dual Timer"]
pub struct DTIM {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DTIM {}
impl DTIM {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dtim::RegisterBlock = 0x4001_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dtim::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DTIM {
    type Target = dtim::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DTIM {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DTIM").finish()
    }
}
#[doc = "Dual Timer"]
pub mod dtim;
#[doc = "Multifunction Timer 0"]
pub struct MFT0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MFT0 {}
impl MFT0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mft0::RegisterBlock = 0x4002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mft0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MFT0 {
    type Target = mft0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MFT0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MFT0").finish()
    }
}
#[doc = "Multifunction Timer 0"]
pub mod mft0;
#[doc = "Multifunction Timer 0"]
pub struct MFT1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MFT1 {}
impl MFT1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mft0::RegisterBlock = 0x4002_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mft0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MFT1 {
    type Target = mft0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MFT1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MFT1").finish()
    }
}
#[doc = "Multifunction Timer 0"]
pub use self::mft0 as mft1;
#[doc = "Multifunction Timer 0"]
pub struct MFT2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MFT2 {}
impl MFT2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mft0::RegisterBlock = 0x4002_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mft0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MFT2 {
    type Target = mft0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MFT2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MFT2").finish()
    }
}
#[doc = "Multifunction Timer 0"]
pub use self::mft0 as mft2;
#[doc = "Base Timer I/O Select"]
pub struct BTIOSEL03 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BTIOSEL03 {}
impl BTIOSEL03 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const btiosel03::RegisterBlock = 0x4002_5100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const btiosel03::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BTIOSEL03 {
    type Target = btiosel03::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BTIOSEL03 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BTIOSEL03").finish()
    }
}
#[doc = "Base Timer I/O Select"]
pub mod btiosel03;
#[doc = "Base Timer I/O Select"]
pub struct BTIOSEL47 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BTIOSEL47 {}
impl BTIOSEL47 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const btiosel47::RegisterBlock = 0x4002_5300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const btiosel47::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BTIOSEL47 {
    type Target = btiosel47::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BTIOSEL47 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BTIOSEL47").finish()
    }
}
#[doc = "Base Timer I/O Select"]
pub mod btiosel47;
#[doc = "Base Timer I/O Select"]
pub struct BTIOSEL8B {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BTIOSEL8B {}
impl BTIOSEL8B {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const btiosel8b::RegisterBlock = 0x4002_5500 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const btiosel8b::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BTIOSEL8B {
    type Target = btiosel8b::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BTIOSEL8B {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BTIOSEL8B").finish()
    }
}
#[doc = "Base Timer I/O Select"]
pub mod btiosel8b;
#[doc = "Base Timer I/O Select"]
pub struct BTIOSELCF {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BTIOSELCF {}
impl BTIOSELCF {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const btioselcf::RegisterBlock = 0x4002_5700 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const btioselcf::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BTIOSELCF {
    type Target = btioselcf::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BTIOSELCF {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BTIOSELCF").finish()
    }
}
#[doc = "Base Timer I/O Select"]
pub mod btioselcf;
#[doc = "Software-based Simultaneous Startup Register"]
pub struct SBSSR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SBSSR {}
impl SBSSR {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sbssr::RegisterBlock = 0x4002_5f00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sbssr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SBSSR {
    type Target = sbssr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SBSSR {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SBSSR").finish()
    }
}
#[doc = "Software-based Simultaneous Startup Register"]
pub mod sbssr;
#[doc = "Base Timer 0"]
pub struct BT0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BT0 {}
impl BT0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bt0::RegisterBlock = 0x4002_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BT0 {
    type Target = bt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BT0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BT0").finish()
    }
}
#[doc = "Base Timer 0"]
pub mod bt0;
#[doc = "Base Timer 0"]
pub struct BT1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BT1 {}
impl BT1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bt0::RegisterBlock = 0x4002_5040 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BT1 {
    type Target = bt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BT1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BT1").finish()
    }
}
#[doc = "Base Timer 0"]
pub use self::bt0 as bt1;
#[doc = "Base Timer 0"]
pub struct BT2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BT2 {}
impl BT2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bt0::RegisterBlock = 0x4002_5080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BT2 {
    type Target = bt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BT2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BT2").finish()
    }
}
#[doc = "Base Timer 0"]
pub use self::bt0 as bt2;
#[doc = "Base Timer 0"]
pub struct BT3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BT3 {}
impl BT3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bt0::RegisterBlock = 0x4002_50c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BT3 {
    type Target = bt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BT3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BT3").finish()
    }
}
#[doc = "Base Timer 0"]
pub use self::bt0 as bt3;
#[doc = "Base Timer 0"]
pub struct BT4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BT4 {}
impl BT4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bt0::RegisterBlock = 0x4002_5200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BT4 {
    type Target = bt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BT4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BT4").finish()
    }
}
#[doc = "Base Timer 0"]
pub use self::bt0 as bt4;
#[doc = "Base Timer 0"]
pub struct BT5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BT5 {}
impl BT5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bt0::RegisterBlock = 0x4002_5240 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BT5 {
    type Target = bt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BT5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BT5").finish()
    }
}
#[doc = "Base Timer 0"]
pub use self::bt0 as bt5;
#[doc = "Base Timer 0"]
pub struct BT6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BT6 {}
impl BT6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bt0::RegisterBlock = 0x4002_5280 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BT6 {
    type Target = bt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BT6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BT6").finish()
    }
}
#[doc = "Base Timer 0"]
pub use self::bt0 as bt6;
#[doc = "Base Timer 0"]
pub struct BT7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BT7 {}
impl BT7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bt0::RegisterBlock = 0x4002_52c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BT7 {
    type Target = bt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BT7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BT7").finish()
    }
}
#[doc = "Base Timer 0"]
pub use self::bt0 as bt7;
#[doc = "Base Timer 0"]
pub struct BT8 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BT8 {}
impl BT8 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bt0::RegisterBlock = 0x4002_5400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BT8 {
    type Target = bt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BT8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BT8").finish()
    }
}
#[doc = "Base Timer 0"]
pub use self::bt0 as bt8;
#[doc = "Base Timer 0"]
pub struct BT9 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BT9 {}
impl BT9 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bt0::RegisterBlock = 0x4002_5440 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BT9 {
    type Target = bt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BT9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BT9").finish()
    }
}
#[doc = "Base Timer 0"]
pub use self::bt0 as bt9;
#[doc = "Base Timer 0"]
pub struct BT10 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BT10 {}
impl BT10 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bt0::RegisterBlock = 0x4002_5480 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BT10 {
    type Target = bt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BT10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BT10").finish()
    }
}
#[doc = "Base Timer 0"]
pub use self::bt0 as bt10;
#[doc = "Base Timer 0"]
pub struct BT11 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BT11 {}
impl BT11 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bt0::RegisterBlock = 0x4002_54c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BT11 {
    type Target = bt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BT11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BT11").finish()
    }
}
#[doc = "Base Timer 0"]
pub use self::bt0 as bt11;
#[doc = "Base Timer 0"]
pub struct BT12 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BT12 {}
impl BT12 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bt0::RegisterBlock = 0x4002_5600 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BT12 {
    type Target = bt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BT12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BT12").finish()
    }
}
#[doc = "Base Timer 0"]
pub use self::bt0 as bt12;
#[doc = "Base Timer 0"]
pub struct BT13 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BT13 {}
impl BT13 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bt0::RegisterBlock = 0x4002_5640 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BT13 {
    type Target = bt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BT13 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BT13").finish()
    }
}
#[doc = "Base Timer 0"]
pub use self::bt0 as bt13;
#[doc = "Base Timer 0"]
pub struct BT14 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BT14 {}
impl BT14 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bt0::RegisterBlock = 0x4002_5680 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BT14 {
    type Target = bt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BT14 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BT14").finish()
    }
}
#[doc = "Base Timer 0"]
pub use self::bt0 as bt14;
#[doc = "Base Timer 0"]
pub struct BT15 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BT15 {}
impl BT15 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bt0::RegisterBlock = 0x4002_56c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for BT15 {
    type Target = bt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BT15 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BT15").finish()
    }
}
#[doc = "Base Timer 0"]
pub use self::bt0 as bt15;
#[doc = "Quadrature Position/Revolution Counter 0"]
pub struct QPRC0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QPRC0 {}
impl QPRC0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qprc0::RegisterBlock = 0x4002_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qprc0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QPRC0 {
    type Target = qprc0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QPRC0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QPRC0").finish()
    }
}
#[doc = "Quadrature Position/Revolution Counter 0"]
pub mod qprc0;
#[doc = "Quadrature Position/Revolution Counter 0"]
pub struct QPRC1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QPRC1 {}
impl QPRC1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qprc0::RegisterBlock = 0x4002_6040 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qprc0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QPRC1 {
    type Target = qprc0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QPRC1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QPRC1").finish()
    }
}
#[doc = "Quadrature Position/Revolution Counter 0"]
pub use self::qprc0 as qprc1;
#[doc = "Quadrature Position/Revolution Counter 0"]
pub struct QPRC2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QPRC2 {}
impl QPRC2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const qprc0::RegisterBlock = 0x4002_6080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const qprc0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for QPRC2 {
    type Target = qprc0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for QPRC2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QPRC2").finish()
    }
}
#[doc = "Quadrature Position/Revolution Counter 0"]
pub use self::qprc0 as qprc2;
#[doc = "Watch Counter"]
pub struct WC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WC {}
impl WC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wc::RegisterBlock = 0x4003_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for WC {
    type Target = wc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for WC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WC").finish()
    }
}
#[doc = "Watch Counter"]
pub mod wc;
#[doc = "PPG Configuration"]
pub struct MFT_PPG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MFT_PPG {}
impl MFT_PPG {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mft_ppg::RegisterBlock = 0x4002_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mft_ppg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MFT_PPG {
    type Target = mft_ppg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MFT_PPG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MFT_PPG").finish()
    }
}
#[doc = "PPG Configuration"]
pub mod mft_ppg;
#[doc = "ADC0 Registers"]
pub struct ADC0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ADC0 {}
impl ADC0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const adc0::RegisterBlock = 0x4002_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const adc0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ADC0 {
    type Target = adc0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ADC0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ADC0").finish()
    }
}
#[doc = "ADC0 Registers"]
pub mod adc0;
#[doc = "ADC0 Registers"]
pub struct ADC1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ADC1 {}
impl ADC1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const adc0::RegisterBlock = 0x4002_7100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const adc0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ADC1 {
    type Target = adc0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ADC1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ADC1").finish()
    }
}
#[doc = "ADC0 Registers"]
pub use self::adc0 as adc1;
#[doc = "ADC0 Registers"]
pub struct ADC2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ADC2 {}
impl ADC2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const adc0::RegisterBlock = 0x4002_7200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const adc0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ADC2 {
    type Target = adc0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ADC2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ADC2").finish()
    }
}
#[doc = "ADC0 Registers"]
pub use self::adc0 as adc2;
#[doc = "External Interrupt and NMI Control"]
pub struct EXTI {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EXTI {}
impl EXTI {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const exti::RegisterBlock = 0x4003_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const exti::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for EXTI {
    type Target = exti::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EXTI {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EXTI").finish()
    }
}
#[doc = "External Interrupt and NMI Control"]
pub mod exti;
#[doc = "Interrupts"]
pub struct INTREQ {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for INTREQ {}
impl INTREQ {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const intreq::RegisterBlock = 0x4003_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const intreq::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for INTREQ {
    type Target = intreq::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for INTREQ {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("INTREQ").finish()
    }
}
#[doc = "Interrupts"]
pub mod intreq;
#[doc = "General-purpose I/O ports"]
pub struct GPIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO {}
impl GPIO {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio::RegisterBlock = 0x4003_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GPIO {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIO").finish()
    }
}
#[doc = "General-purpose I/O ports"]
pub mod gpio;
#[doc = "Low-voltage Detection"]
pub struct LVD {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LVD {}
impl LVD {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lvd::RegisterBlock = 0x4003_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lvd::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for LVD {
    type Target = lvd::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LVD {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LVD").finish()
    }
}
#[doc = "Low-voltage Detection"]
pub mod lvd;
#[doc = "Multi-function Serial Interface 0"]
pub struct MFS0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MFS0 {}
impl MFS0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mfs0::RegisterBlock = 0x4003_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mfs0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MFS0 {
    type Target = mfs0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MFS0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MFS0").finish()
    }
}
#[doc = "Multi-function Serial Interface 0"]
pub mod mfs0;
#[doc = "Multi-function Serial Interface 0"]
pub struct MFS1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MFS1 {}
impl MFS1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mfs0::RegisterBlock = 0x4003_8100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mfs0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MFS1 {
    type Target = mfs0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MFS1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MFS1").finish()
    }
}
#[doc = "Multi-function Serial Interface 0"]
pub use self::mfs0 as mfs1;
#[doc = "Multi-function Serial Interface 0"]
pub struct MFS2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MFS2 {}
impl MFS2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mfs0::RegisterBlock = 0x4003_8200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mfs0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MFS2 {
    type Target = mfs0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MFS2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MFS2").finish()
    }
}
#[doc = "Multi-function Serial Interface 0"]
pub use self::mfs0 as mfs2;
#[doc = "Multi-function Serial Interface 0"]
pub struct MFS3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MFS3 {}
impl MFS3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mfs0::RegisterBlock = 0x4003_8300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mfs0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MFS3 {
    type Target = mfs0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MFS3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MFS3").finish()
    }
}
#[doc = "Multi-function Serial Interface 0"]
pub use self::mfs0 as mfs3;
#[doc = "Multi-function Serial Interface 4"]
pub struct MFS4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MFS4 {}
impl MFS4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mfs4::RegisterBlock = 0x4003_8400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mfs4::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MFS4 {
    type Target = mfs4::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MFS4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MFS4").finish()
    }
}
#[doc = "Multi-function Serial Interface 4"]
pub mod mfs4;
#[doc = "Multi-function Serial Interface 4"]
pub struct MFS5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MFS5 {}
impl MFS5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mfs4::RegisterBlock = 0x4003_8500 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mfs4::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MFS5 {
    type Target = mfs4::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MFS5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MFS5").finish()
    }
}
#[doc = "Multi-function Serial Interface 4"]
pub use self::mfs4 as mfs5;
#[doc = "Multi-function Serial Interface 4"]
pub struct MFS6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MFS6 {}
impl MFS6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mfs4::RegisterBlock = 0x4003_8600 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mfs4::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MFS6 {
    type Target = mfs4::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MFS6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MFS6").finish()
    }
}
#[doc = "Multi-function Serial Interface 4"]
pub use self::mfs4 as mfs6;
#[doc = "Multi-function Serial Interface 4"]
pub struct MFS7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MFS7 {}
impl MFS7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mfs4::RegisterBlock = 0x4003_8700 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mfs4::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MFS7 {
    type Target = mfs4::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MFS7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MFS7").finish()
    }
}
#[doc = "Multi-function Serial Interface 4"]
pub use self::mfs4 as mfs7;
#[doc = "I2C Auxiliary Noise Filter Setting Register"]
pub struct MFS_NFC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MFS_NFC {}
impl MFS_NFC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mfs_nfc::RegisterBlock = 0x4003_8800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mfs_nfc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MFS_NFC {
    type Target = mfs_nfc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MFS_NFC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MFS_NFC").finish()
    }
}
#[doc = "I2C Auxiliary Noise Filter Setting Register"]
pub mod mfs_nfc;
#[doc = "CRC Registers"]
pub struct CRC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CRC {}
impl CRC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const crc::RegisterBlock = 0x4003_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const crc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CRC {
    type Target = crc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CRC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CRC").finish()
    }
}
#[doc = "CRC Registers"]
pub mod crc;
#[doc = "External Bus Interface"]
pub struct EXBUS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EXBUS {}
impl EXBUS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const exbus::RegisterBlock = 0x4003_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const exbus::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for EXBUS {
    type Target = exbus::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EXBUS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EXBUS").finish()
    }
}
#[doc = "External Bus Interface"]
pub mod exbus;
#[doc = "USB/Ethernet Clock"]
pub struct USBETHERCLK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USBETHERCLK {}
impl USBETHERCLK {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usbetherclk::RegisterBlock = 0x4003_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usbetherclk::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for USBETHERCLK {
    type Target = usbetherclk::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USBETHERCLK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USBETHERCLK").finish()
    }
}
#[doc = "USB/Ethernet Clock"]
pub mod usbetherclk;
#[doc = "USB0 Function"]
pub struct USB0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USB0 {}
impl USB0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0::RegisterBlock = 0x4004_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for USB0 {
    type Target = usb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USB0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USB0").finish()
    }
}
#[doc = "USB0 Function"]
pub mod usb0;
#[doc = "USB0 Function"]
pub struct USB1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USB1 {}
impl USB1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb0::RegisterBlock = 0x4005_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for USB1 {
    type Target = usb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USB1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USB1").finish()
    }
}
#[doc = "USB0 Function"]
pub use self::usb0 as usb1;
#[doc = "DMAC Registers"]
pub struct DMAC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMAC {}
impl DMAC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmac::RegisterBlock = 0x4006_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmac::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DMAC {
    type Target = dmac::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMAC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMAC").finish()
    }
}
#[doc = "DMAC Registers"]
pub mod dmac;
#[doc = "Ethernet-MAC 0"]
pub struct ETHERNET_MAC0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ETHERNET_MAC0 {}
impl ETHERNET_MAC0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ethernet_mac0::RegisterBlock = 0x4006_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ethernet_mac0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ETHERNET_MAC0 {
    type Target = ethernet_mac0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ETHERNET_MAC0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ETHERNET_MAC0").finish()
    }
}
#[doc = "Ethernet-MAC 0"]
pub mod ethernet_mac0;
#[doc = "Ethernet system control"]
pub struct ETHERNET_CONTROL {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ETHERNET_CONTROL {}
impl ETHERNET_CONTROL {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ethernet_control::RegisterBlock = 0x4006_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ethernet_control::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ETHERNET_CONTROL {
    type Target = ethernet_control::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ETHERNET_CONTROL {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ETHERNET_CONTROL").finish()
    }
}
#[doc = "Ethernet system control"]
pub mod ethernet_control;
#[doc = "Ethernet-MAC 0"]
pub struct ETHERNET_MAC1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ETHERNET_MAC1 {}
impl ETHERNET_MAC1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ethernet_mac0::RegisterBlock = 0x4006_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ethernet_mac0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ETHERNET_MAC1 {
    type Target = ethernet_mac0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ETHERNET_MAC1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ETHERNET_MAC1").finish()
    }
}
#[doc = "Ethernet-MAC 0"]
pub use self::ethernet_mac0 as ethernet_mac1;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "FLASH_IF"]
    pub FLASH_IF: FLASH_IF,
    #[doc = "CRG"]
    pub CRG: CRG,
    #[doc = "CRTRIM"]
    pub CRTRIM: CRTRIM,
    #[doc = "SWWDT"]
    pub SWWDT: SWWDT,
    #[doc = "HWWDT"]
    pub HWWDT: HWWDT,
    #[doc = "DTIM"]
    pub DTIM: DTIM,
    #[doc = "MFT0"]
    pub MFT0: MFT0,
    #[doc = "MFT1"]
    pub MFT1: MFT1,
    #[doc = "MFT2"]
    pub MFT2: MFT2,
    #[doc = "BTIOSEL03"]
    pub BTIOSEL03: BTIOSEL03,
    #[doc = "BTIOSEL47"]
    pub BTIOSEL47: BTIOSEL47,
    #[doc = "BTIOSEL8B"]
    pub BTIOSEL8B: BTIOSEL8B,
    #[doc = "BTIOSELCF"]
    pub BTIOSELCF: BTIOSELCF,
    #[doc = "SBSSR"]
    pub SBSSR: SBSSR,
    #[doc = "BT0"]
    pub BT0: BT0,
    #[doc = "BT1"]
    pub BT1: BT1,
    #[doc = "BT2"]
    pub BT2: BT2,
    #[doc = "BT3"]
    pub BT3: BT3,
    #[doc = "BT4"]
    pub BT4: BT4,
    #[doc = "BT5"]
    pub BT5: BT5,
    #[doc = "BT6"]
    pub BT6: BT6,
    #[doc = "BT7"]
    pub BT7: BT7,
    #[doc = "BT8"]
    pub BT8: BT8,
    #[doc = "BT9"]
    pub BT9: BT9,
    #[doc = "BT10"]
    pub BT10: BT10,
    #[doc = "BT11"]
    pub BT11: BT11,
    #[doc = "BT12"]
    pub BT12: BT12,
    #[doc = "BT13"]
    pub BT13: BT13,
    #[doc = "BT14"]
    pub BT14: BT14,
    #[doc = "BT15"]
    pub BT15: BT15,
    #[doc = "QPRC0"]
    pub QPRC0: QPRC0,
    #[doc = "QPRC1"]
    pub QPRC1: QPRC1,
    #[doc = "QPRC2"]
    pub QPRC2: QPRC2,
    #[doc = "WC"]
    pub WC: WC,
    #[doc = "MFT_PPG"]
    pub MFT_PPG: MFT_PPG,
    #[doc = "ADC0"]
    pub ADC0: ADC0,
    #[doc = "ADC1"]
    pub ADC1: ADC1,
    #[doc = "ADC2"]
    pub ADC2: ADC2,
    #[doc = "EXTI"]
    pub EXTI: EXTI,
    #[doc = "INTREQ"]
    pub INTREQ: INTREQ,
    #[doc = "GPIO"]
    pub GPIO: GPIO,
    #[doc = "LVD"]
    pub LVD: LVD,
    #[doc = "MFS0"]
    pub MFS0: MFS0,
    #[doc = "MFS1"]
    pub MFS1: MFS1,
    #[doc = "MFS2"]
    pub MFS2: MFS2,
    #[doc = "MFS3"]
    pub MFS3: MFS3,
    #[doc = "MFS4"]
    pub MFS4: MFS4,
    #[doc = "MFS5"]
    pub MFS5: MFS5,
    #[doc = "MFS6"]
    pub MFS6: MFS6,
    #[doc = "MFS7"]
    pub MFS7: MFS7,
    #[doc = "MFS_NFC"]
    pub MFS_NFC: MFS_NFC,
    #[doc = "CRC"]
    pub CRC: CRC,
    #[doc = "EXBUS"]
    pub EXBUS: EXBUS,
    #[doc = "USBETHERCLK"]
    pub USBETHERCLK: USBETHERCLK,
    #[doc = "USB0"]
    pub USB0: USB0,
    #[doc = "USB1"]
    pub USB1: USB1,
    #[doc = "DMAC"]
    pub DMAC: DMAC,
    #[doc = "ETHERNET_MAC0"]
    pub ETHERNET_MAC0: ETHERNET_MAC0,
    #[doc = "ETHERNET_CONTROL"]
    pub ETHERNET_CONTROL: ETHERNET_CONTROL,
    #[doc = "ETHERNET_MAC1"]
    pub ETHERNET_MAC1: ETHERNET_MAC1,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            FLASH_IF: FLASH_IF {
                _marker: PhantomData,
            },
            CRG: CRG {
                _marker: PhantomData,
            },
            CRTRIM: CRTRIM {
                _marker: PhantomData,
            },
            SWWDT: SWWDT {
                _marker: PhantomData,
            },
            HWWDT: HWWDT {
                _marker: PhantomData,
            },
            DTIM: DTIM {
                _marker: PhantomData,
            },
            MFT0: MFT0 {
                _marker: PhantomData,
            },
            MFT1: MFT1 {
                _marker: PhantomData,
            },
            MFT2: MFT2 {
                _marker: PhantomData,
            },
            BTIOSEL03: BTIOSEL03 {
                _marker: PhantomData,
            },
            BTIOSEL47: BTIOSEL47 {
                _marker: PhantomData,
            },
            BTIOSEL8B: BTIOSEL8B {
                _marker: PhantomData,
            },
            BTIOSELCF: BTIOSELCF {
                _marker: PhantomData,
            },
            SBSSR: SBSSR {
                _marker: PhantomData,
            },
            BT0: BT0 {
                _marker: PhantomData,
            },
            BT1: BT1 {
                _marker: PhantomData,
            },
            BT2: BT2 {
                _marker: PhantomData,
            },
            BT3: BT3 {
                _marker: PhantomData,
            },
            BT4: BT4 {
                _marker: PhantomData,
            },
            BT5: BT5 {
                _marker: PhantomData,
            },
            BT6: BT6 {
                _marker: PhantomData,
            },
            BT7: BT7 {
                _marker: PhantomData,
            },
            BT8: BT8 {
                _marker: PhantomData,
            },
            BT9: BT9 {
                _marker: PhantomData,
            },
            BT10: BT10 {
                _marker: PhantomData,
            },
            BT11: BT11 {
                _marker: PhantomData,
            },
            BT12: BT12 {
                _marker: PhantomData,
            },
            BT13: BT13 {
                _marker: PhantomData,
            },
            BT14: BT14 {
                _marker: PhantomData,
            },
            BT15: BT15 {
                _marker: PhantomData,
            },
            QPRC0: QPRC0 {
                _marker: PhantomData,
            },
            QPRC1: QPRC1 {
                _marker: PhantomData,
            },
            QPRC2: QPRC2 {
                _marker: PhantomData,
            },
            WC: WC {
                _marker: PhantomData,
            },
            MFT_PPG: MFT_PPG {
                _marker: PhantomData,
            },
            ADC0: ADC0 {
                _marker: PhantomData,
            },
            ADC1: ADC1 {
                _marker: PhantomData,
            },
            ADC2: ADC2 {
                _marker: PhantomData,
            },
            EXTI: EXTI {
                _marker: PhantomData,
            },
            INTREQ: INTREQ {
                _marker: PhantomData,
            },
            GPIO: GPIO {
                _marker: PhantomData,
            },
            LVD: LVD {
                _marker: PhantomData,
            },
            MFS0: MFS0 {
                _marker: PhantomData,
            },
            MFS1: MFS1 {
                _marker: PhantomData,
            },
            MFS2: MFS2 {
                _marker: PhantomData,
            },
            MFS3: MFS3 {
                _marker: PhantomData,
            },
            MFS4: MFS4 {
                _marker: PhantomData,
            },
            MFS5: MFS5 {
                _marker: PhantomData,
            },
            MFS6: MFS6 {
                _marker: PhantomData,
            },
            MFS7: MFS7 {
                _marker: PhantomData,
            },
            MFS_NFC: MFS_NFC {
                _marker: PhantomData,
            },
            CRC: CRC {
                _marker: PhantomData,
            },
            EXBUS: EXBUS {
                _marker: PhantomData,
            },
            USBETHERCLK: USBETHERCLK {
                _marker: PhantomData,
            },
            USB0: USB0 {
                _marker: PhantomData,
            },
            USB1: USB1 {
                _marker: PhantomData,
            },
            DMAC: DMAC {
                _marker: PhantomData,
            },
            ETHERNET_MAC0: ETHERNET_MAC0 {
                _marker: PhantomData,
            },
            ETHERNET_CONTROL: ETHERNET_CONTROL {
                _marker: PhantomData,
            },
            ETHERNET_MAC1: ETHERNET_MAC1 {
                _marker: PhantomData,
            },
        }
    }
}
